import React, { useRef, useEffect, useState } from "react";

// Snake Duel
// Single-file React component (Tailwind CSS expected in host project)
// Controls:
//  - Player: Arrow keys or WASD
//  - AI: computer-controlled snake
// Features:
//  - 2 snakes (player vs AI)
//  - Keeps score (localStorage)
//  - Start / Pause / Reset / Difficulty
//  - Responsive canvas

const GRID_COLS = 32;
const GRID_ROWS = 20;
const DEFAULT_SPEED = 120; // ms per tick (lower = faster)

const DIRECTIONS = {
  ArrowUp: [0, -1],
  ArrowDown: [0, 1],
  ArrowLeft: [-1, 0],
  ArrowRight: [1, 0],
  w: [0, -1],
  s: [0, 1],
  a: [-1, 0],
  d: [1, 0],
};

function randInt(min, max) {
  return Math.floor(Math.random() * (max - min + 1)) + min;
}

function posEq(a, b) {
  return a[0] === b[0] && a[1] === b[1];
}

function insideGrid(x, y) {
  return x >= 0 && x < GRID_COLS && y >= 0 && y < GRID_ROWS;
}

// Basic BFS pathfinder for AI (avoids obstacle positions set)
function bfs(start, target, obstacles) {
  const key = (p) => `${p[0]}:${p[1]}`;
  const q = [start];
  const came = new Map();
  came.set(key(start), null);
  const moves = [[1,0],[-1,0],[0,1],[0,-1]];

  while (q.length) {
    const cur = q.shift();
    if (posEq(cur, target)) break;
    for (const m of moves) {
      const nxt = [cur[0] + m[0], cur[1] + m[1]];
      const k = key(nxt);
      if (!insideGrid(nxt[0], nxt[1]) || came.has(k)) continue;
      if (obstacles.has(k) && !posEq(nxt, target)) continue;
      came.set(k, cur);
      q.push(nxt);
    }
  }

  const targetKey = key(target);
  if (!came.has(targetKey)) return null;

  // reconstruct path
  const path = [];
  let curKey = targetKey;
  while (curKey) {
    const [x,y] = curKey.split(":").map(Number);
    path.unshift([x,y]);
    const prev = came.get(curKey);
    curKey = prev ? `${prev[0]}:${prev[1]}` : null;
  }
  return path; // includes start and target
}

export default function SnakeDuel() {
  const canvasRef = useRef(null);
  const [running, setRunning] = useState(false);
  const [tickMs, setTickMs] = useState(DEFAULT_SPEED);
  const [playerScore, setPlayerScore] = useState(() => Number(localStorage.getItem('snake_player_score') || 0));
  const [aiScore, setAiScore] = useState(() => Number(localStorage.getItem('snake_ai_score') || 0));
  const [difficulty, setDifficulty] = useState('Normal');
  const [message, setMessage] = useState('');

  // Game state held in ref to update from interval without re-rendering the canvas constantly
  const stateRef = useRef();

  function resetState() {
    const centerX = Math.floor(GRID_COLS / 4);
    const centerXAi = Math.floor(GRID_COLS * 3 / 4);
    const initial = {
      player: {
        dir: [1, 0],
        cells: [ [centerX, Math.floor(GRID_ROWS/2)], [centerX-1, Math.floor(GRID_ROWS/2)], [centerX-2, Math.floor(GRID_ROWS/2)] ],
      },
      ai: {
        dir: [-1, 0],
        cells: [ [centerXAi, Math.floor(GRID_ROWS/2)], [centerXAi+1, Math.floor(GRID_ROWS/2)], [centerXAi+2, Math.floor(GRID_ROWS/2)] ],
      },
      apple: null,
      tick: 0,
      lastPlayerInput: null,
    };
    initial.apple = spawnApple(initial.player.cells.concat(initial.ai.cells));
    stateRef.current = initial;
  }

  function spawnApple(occupied) {
    const occSet = new Set(occupied.map(p => `${p[0]}:${p[1]}`));
    const empties = [];
    for (let x=0;x<GRID_COLS;x++) for (let y=0;y<GRID_ROWS;y++) {
      const k = `${x}:${y}`;
      if (!occSet.has(k)) empties.push([x,y]);
    }
    if (empties.length === 0) return [0,0];
    return empties[randInt(0, empties.length-1)];
  }

  // init
  useEffect(() => {
    resetState();
    draw();
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);

  useEffect(() => {
    localStorage.setItem('snake_player_score', String(playerScore));
  }, [playerScore]);
  useEffect(() => {
    localStorage.setItem('snake_ai_score', String(aiScore));
  }, [aiScore]);

  // handle keyboard
  useEffect(() => {
    function onKey(e) {
      const key = e.key;
      if (!DIRECTIONS[key]) return;
      const next = DIRECTIONS[key];
      const st = stateRef.current;
      if (!st) return;
      const curDir = st.player.dir;
      // prevent reversing
      if (next[0] === -curDir[0] && next[1] === -curDir[1]) return;
      st.player.dir = next;
      st.lastPlayerInput = Date.now();
      e.preventDefault();
    }
    window.addEventListener('keydown', onKey);
    return () => window.removeEventListener('keydown', onKey);
  }, []);

  // game loop
  useEffect(() => {
    if (!running) return;
    let last = performance.now();
    let acc = 0;
    const step = (now) => {
      const dt = now - last;
      last = now;
      acc += dt;
      if (acc >= tickMs) {
        acc -= tickMs;
        tick();
      }
      requestAnimationFrame(step);
    };
    const raf = requestAnimationFrame(step);
    return () => cancelAnimationFrame(raf);
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [running, tickMs]);

  // AI difficulty adjust
  useEffect(() => {
    if (difficulty === 'Easy') setTickMs(160);
    else if (difficulty === 'Normal') setTickMs(110);
    else if (difficulty === 'Hard') setTickMs(70);
  }, [difficulty]);

  function tick() {
    const st = stateRef.current;
    if (!st) return;
    st.tick++;

    // --- AI decides direction via BFS path toward apple avoiding obstacles ---
    const occ = new Set();
    for (const c of st.player.cells)